# Module 5 scripts 

## 5.1
 
Welcome to Module 5, the final group of lessons in this course. We've come a long way since first learning about binary and other number bases, then logic, then sets and functions and then counting. In this last module, we will focus in on perhaps the biggest concept of the whole course --- *recursion*. We've seen this idea before, particulary with the binomial coefficient, and in this module we're going to drill deeply into this idea and learn how to work with recursion and how to craft mathematically sound arguments about recursion. But first let's start small. 

Here's an interesting visual pattern that I'd like you to think about. It's a sequence of figures. THe first figure is just a circle. The second is this triangle. Then the third is this triangle. Here's the fourth. Pause the video now, and see if you can guess the pattern and draw the next figure in the list. 

Here's the next one that I had in mind. What's the pattern exactly? It looks like in order to create a new figure, we look back at the previous figure and add a row of dots along the right side of the triangle. So the fifth figure should look like this. 

Now let's count the number of circles in each figure. The first one has 1. The second 3, then 6, then 10, then 15. Can you guess the next one? Can you guess it without drawing a triangle? Try it! 

Did you guess 21? Let's draw the triangle and see: here it is. The visual pattern says we make the new triangle by taking the previous one and adding a row of circles on the right. We already know that the previous figure has 15. Since the previous right side had five circles, the new one should have six. We just need to add the 6 circles here, so that's 21. 

This list of numbers is called a *sequence*. This word refers to any ordered sequence of numbers. The numbers in a sequence are called the *terms* of the sequence. So not a *set* of things, but a *list* with a definite first term, second term, third term, and so on. Sequences occur throughout mathematics and computer science in all kinds of ways, and they are often a key to many applications as well as interesting objects unto themselves. 

We often label the terms of a sequence with a letter and a subscript. For example to denote this sequence 1, 3, 6, 10, 15, 21, and so forth we could use the letter T (for triangle) with subscripts to tell which term in the list we mean, so T_1 is 1, T_2 is 3, T_3 is 6, T_4 is 10, and so on. A number in a subscript is called an *index* and the plural form of index is *indices*. This particular sequence has a special name, the *triangular numbers* because the numbers emerge from this visual pattern you see here. 

Here's another sequence, which this time starts the index at 0: f_0 = 1, f_1 = 1, f_2 = 2, f_3 = 3, f_4 = 5, f_5 = 8, and so on. First of all note that unlike with sets, sequences can and often do have duplicate terms. THe pattern in this sequence is that the first two terms are both 1, and every other term is the sum of the previous two. This one is called the Fibonacci sequence and it plays a big role in mathematics and computer science. 

Sequences can also be spelled out with a formula, like this: The sequence g where g_i is equal to 2**i for each i in the natural numbers. So g_0 = 1, g_1 = 2, g_2 = 4, g_3 = 8, and so on. 

Sequences don't *have* to have any pattern at all. Look at the sequence h given by h_0 = 3, h_1 = 1, h_2 = 4, h_3 = 1, h_4 = 5, h_5 = 9, and so on. The "pattern" here is that h_n is the nth digit of the number pi. There's no formula or pattern here, just a direct mapping from the index to the digit. 

As we just saw, there are two main ways to generate sequences. One is with a closed formula, where you plug in the index and the formula tells you what the sequence term is at that index. For example the sequence g where g_i is equal to 2**i uses a closed formula, and we can quickly generate as many terms in this sequence as we want using Python, or a spreadsheet. Here's another, b_n = 3(1.1)^n and here are the first 10 terms of that sequence. This also shows you that sequences don't have to consist only of integers -- although the indices in a sequence have to be integers because they count the positions of the terms. 

The other major way to generate a sequence gets us to the heart of this module --- we can define sequences recursively. A recursive definition of a sequence computes an term of a sequence in terms of one or more of the previous terms in the sequence. The Fibonacci sequence was recursive because the third, fourth and so on terms of the sequence were the sum of the previous two. We can phrase this using notation by writing f_n = f_{n-1} + f_{n-2}. That relationship is called a *recurrence relation* --- A recurrence relation is a math expression that tells how one term in the sequence relates to previous terms. We also had some starting terms given as part of the definition of the sequence. Those starting terms are called the initial condition. 

A complete recursive definition of a sequence requires both a recurrence relation *and* an initial condition. With both the recurrence relation and the initial condition in place, we can compute any term of the sequence we want. If we wanted to know what f_3 is in the Fibonacci numbers, then it's equal to f_2 + f_1. But what's f_2? Well, that's f_1 + f_0. If I had *only* the recurrence relation, it would just keep pushing me further and further back in the sequence -- in order to actually find the terms in the sequence, I need a starting point. That's called an *initial condition*. In the Fibonacci numbers, the initial conditions are f_0 = 1 and f_1 = 1. Again with those initial conditions *and* the recurrence relation, I can compute any term of the sequence I wanted. 

For example look at a_n = 2 * a_{n-1} with initial condition a_0 = 3. Let's write out the first 5 terms of this sequence. Well, the first one, a_0, is given to you: It's 3. a_1 by the recurrence relation is equal to 2*a_0  and a_0 is 3, so a_1 is 6. Likewise a_2 is 2 times a_1, so that's 12. Pause the video and see if you can get a3 and a4. 

So, a3 is 2*a2 which is 2 times 12 or 24. And a4 is 2 times a3 which is 2 times 24 which is 48. So those are your first five terms: 3, 6, 12, 24, 48. We're doubling each time, which makes sense when you look at the recurrence relation. Notice with this sequence we needed only one initial condition because you only had to go back one step in the sequence to compute a new term. Whereas with the Fibonacci numbers, you had to go back two steps, so we needed two initial conditions. 

Many times we can represent a recursive sequence with a closed formula, and vice versa. It's going to be important to phrase a given sequence in both ways if possible. Let's try this with the triangular numbers we opened with: T_1 = 1, T_2 = 3, T_3 = 6, T_4 = 10, T_5 = 15, T_6 = 21. Can we first come up with a recursive definition for this sequence? It helps to go back to the visual pattern. The first number is 1. The second one we got by adding two circles on the triangle. The third we got by taking the second figure and adding 3 circles onto the triangle. The fourth one we got by taking the third, and adding four circles. I think I'm beginning to understand the pattern: At stage n, I get T_n by dropping back to the previous stage, n-1, and adding n circles. So T_n should be T_{n-1} + n. That's the right recurrence relation, so all I need is the initial condition, which is T_1 = 1. 

Here's a recursive Python function that should generate this sequence. You can see in the second line I have the initial condition coded in, and then in the remaining lines it uses a recursive function call to implement the recurrence relation. Down below I'm going to make a list comprehension with this function to generate terms of the sequence. And when I execute it, I can see that it seems to be generating the right numbers, so I think my recursive definition, both the recurrence relation and the initial conditions, was right. 

What about a closed formula for this? This is harder here. Just looking at the numbers, it's hard to guess --- there's not a totally obvious formula that produces all these. But remember the problem-solving concept of *looking at the problem in different ways*. If I look back at the picture and draw the triangle more like this, I can make a copy of that triangle and rotate it, and attach it to the original triangle to form a rectangle like this. This rectangle has n circles on one side and n+1 on the other. The total number of circles in the rectangle is n times n+1. But the original triangle has exactly half of those circles in it, which is n(n+1)/2. So that's a closed formula. Is it right? Here's a list comprehension that tests this directly, and I can see that it produces the same sequence. Note there's no need for initial conditions with a closed formula -- the formula just directly produces the output. 

In this video you learned what a sequence is, how to represent one recursively using a recurrence relation and initial conditions, and how to represent one as a closed formula. And we've gotten a taste of how to look at a visual pattern and write a recursive definition for it, also how to use the same visual pattern to write a closed formula. Next up we will discuss how to add and multiply terms of a sequence together using a notational trick. 

## 5.2

One of the things we often do with sequences, which we learned about in the last video, is add their elements together or multiply them together. This video is going to demonstrate some mathematical notation for writing these in a compact and efficient way. 

First, realize that when we say "add or multiply the elements of a sequence" we don't necessarily mean ALL the elements. Sequences are infinite, and it's a tricky question as to whether it even makes sense to "Add up infinitely many things". That's a question that requires ideas from calculus to answer. So for us, when we speak of "adding" or "multiplying" terms of a sequence, for us we mean a *partial sum* or *partial product* --- starting at a certain point in the sequence (usually the beginning) and adding up or multiplying together the first "n" elements of a sequence. For example, in the sequence given by f(n) = 2**n where n starts at 0, here's the sum of the first 5 terms and the product of the first 5 terms, called the fifth partial sum and fifth partial product respectively. 

To write the sum of a sequence "a" starting at index 1 and going through index n, we write this: The big symbol here is a giant Greek capital letter "sigma", which starts with s to remind you of sums. Read this as "the sum of a_k, from k = 1 to k = n". THis means a1 plus a2 plus a3 plus a4, and so on through an. We can change a lot in this "sigma notation". For example the name of the index is irrelevant. We can also start the summing in a different place, or end it in a different place, or both. 

For example here's the sum of 2^i where i goes from 0 through 4 as we saw above, and here's the sum of 2^k where k goes from 3 to 8. Notice it doesn't really matter what I call the index, as long as it's the same variable used inside the sigma -- it's just a counting variable, like you would use in a FOR loop. Also there's no rule saying the counter must start at 0 or 1. 

In fact, sigma notation is really just a mathematical way of writing a FOR loop with an accumulating variable that we change by adding. For example, this sigma notation adds up the expression n(n+1)/2 from n = 0 to 10. Here's the corresponding FOR loop that does the same thing. And you can also do this with a list comprehension by generating a list of the terms of the sum and then using the `sum` command to add them up. 

We can also multiply sequence elements together, and we use a giant Greek letter pi for that. So this notation means take the elements of sequence "a" from 0 through n, and multiply them together. For example, the product of k^2 from k = 1 to 8 is this number. Notice that if we look at the product of just the variable "k" from 1 to n, this is 1 times 2 times 3 times and so on up through n-1 times n, which is n factorial. 

Just as sigma notation is math shorthand for a FOR loop that accumulates by adding, pi notation is shorthand for a FOR loop that accumulates by multiplying. For example this product is equivalent to this FOR loop. 

In this video you learned the sigma notation shorthand for adding up a finite piece of a sequence and pi notation for multiplying elements of a sequence. THis shorthand helps us think and write about mathematical ideas, as we'll see later. 


## 5.3 

So far in this module we've learned what a sequence is, how to represent sequences using closed formulas and recursive definitions, and how to use sigma and pi notation to find partial sums and products of sequences. In this video we're going to examine two special types of sequences that have some distinctive behaviors. 

Take a look at this visual pattern and let's see if we can count the number of stars at each stage. Let s_n be the number of stars in the figure at stage n. If we start the indexing at 1, then s_1 is 3, s_2 is 5, and s_3 is 7. I bet you can probably guess what the next several terms of the sequence are going to be, without either a closed formula or a recursive definition. It's a safe guess that s_4 will be 9, then s_5 is 11, and so on because all we are doing to get from one stage to the next is taking the current stage and adding 2. We can say in this case the sequence is increasing by a constant amount --- namely 2 each time I go from one stage to the next. 

A sequence with this behavior, where the terms in the sequence change by a constant amount every time we go from one term to the next, is called an *arithmetic sequence*. So this is an arithmetic sequence, and here's another. The first sequence on this slide is arithmetic because the terms increase by a constant amount of 2 each time. The second is also considered arithmetic, even though the terms are decreasing, because they are still changing by a constant amount, this time dropping by 3. But this sequence is not arithmetic because the difference between the first and second terms is 3 but the difference between the second and third terms is 6. Since that's not the same amount, this is not arithmetic. 

Arithmetic sequence increase (or decrease) like a staircase, always moving up (or down) by the same height each time we take a step. 

Coming up with closed formulas and recursive definitions for arithmetic sequences is fairly easy. To get a closed formula for our star sequence for example, we can use some concepts from basic algebra. If you think of a sequence as a function, which is what we do when we make a closed formula for it, then what you might notice about this function is that it increases at a constant rate, always up 2 for every increase of 1 in the input. Functions that behave like that are called *linear* functions. Linear functions are completely defined by their slope, which is the rate at which they change, and a point on the graph of that function. Well, the slope here is 2 because every increase of 1 in the input produces a change of 2 in the output. And I can look at the data here and see that the point (1,3) is on the graph of this function. So using what we called the point-slope form for the equation of a line back in algebra. we can write y - y1 = m(x-x1), or y - 3 = 2(x-1). That simplifies to y = 2x+1 so the closed formula is a_n = 2n + 1. Using a little Python to check shows me that this seems right. 

A recursive definition is even easier because we don't need any algebra. Just first of all realize that from the visual pattern, to get the figure at stage n we look back one step to n-1 and add 2. So the recurrence relation for this sequence would be a_n = a_{n-1} + 2. Since we go back one step, we need one initial condition, and we can get that from the picture -- a_1 = 3. 

Let's go back to a sequence we saw earlier that was NOT arithmetic. It had terms 3, 6, 12, 24, 48, and so on. This wasn't arithmetic because it didn't increase by the same *amount* each time. But you might have noticed that the terms do have some very noticeable behavior --- they *double* each time. So this the terms of this sequence increase not by the same *amount* but by the same *factor*. 

Here's another sequence whose terms change by the same factor: 1, 1/3, 1/9, 1/27, 1/81, and so on. The differences between the terms aren't always the same so this is not an arithmetic sequence. But there is a common multiple between each term --- each term is obtained by taking the previous one and multiplying by 1/3 (or dividing by 3). So each term is one-third the size of the one that came before it. 

A sequence like these, where the terms change by the same *factor*, is called a *geometric sequence*. You just saw two examples of geometric sequences. Here's another, because the terms are increasing by a factor of 5 each time. Here's one that is not geometric, because the second term is 2 times the first one but the third term is 3 times the second one. Since that's not the same multiple each time, it's not geometric. 

Just as with arithmetic sequences, geometric sequences are fairly simple to represent recursively or in closed form. Look at our first example. Recursively, we just note again that each term is twice the one before it. So the recurrence relation should be a_n = 2*a_{n-1} for n > 1. And for the initial condition, just look at the first term of the sequence to see that a_1 = 3. Likewise the second sequence would have an initial condition b_1 = 1, and for n > 1 we'd have b_n = 1/3 ( b_{n-1}. )

Closed formulas for geometric sequences are a little harder because they aren't linear functions but instead what we call *exponential* functions. The recurrence relation can actually help here: In this sequence, I start with a_1 = 3 and then if I want to go to the nth term, I need to multiply this by 2, n-1 times. So the formula would be a_n = 3(2)^(n-1). We can check to see that this is correct with Python or a spreadsheet. 

Let's review this for a moment. Here are four sequences. Pause the video and label each one as arithmetic, geometric, or neither. 

Only the second sequence is arithmetic, because the terms are going up by the same amount, 4, each time. Looking at the differences between terms in the other three shows you that those *don't* increase by the same amount each time. 

Likewise I can tell which one is geometric here by looking at the ratios between the terms. Wherever there's a common *ratio*, there's a geometric sequence. The fouth sequence here is the only one that's geometric because the terms are increasing not by a constant amount but by a constant *factor*, being multiplied by 1.1 each time. 

In this video, we learned what arithmetic and geometric sequences are, and methods for expressing both as closed formulas and recursively. Next up, we start a mini-series of videos on taking recurrence relations and figuring out ways to express those as closed formulas. We just saw how this might work in the special cases of arithmetic and geometric sequences, but what if the sequence is neither? Stay tuned. 

## 5.4 

This video is the first of a mini-series in module 5 about *solving recurrence relations*. The purpose of this video is to define what we mean by "solving" a recurrence relation and outlining a method to check a solution to a recurrence relation. 

Remember that a recurrence relation for a sequence or some other recursively defined object is an equation, that relates one term in the sequence to one or more previously-computed terms along with perhaps some additional computations. For example we saw a recurrence relation for the triangular numbers arising from this visual pattern was T_n = T_{n-1} + n. That is a *relation* that describes how these sequence elements *recur*. Recurrence relations also have initial conditions that allow us to actually compute elements of the sequence by breaking terms down further and further using the recurrence relation until we are left with the initial conditions. 

So recurrence relations with initial conditions allow us to compute things recursively. But just because we *can* compute something recursively doesn't mean we *should*. For example, the binomial coefficient obeys a recurrence relation and has initial conditions. But computing, say, 26 choose 10 recursively would be a tremendous amount of work even for a computer because of the memory requirements. 

So, instead, while recurrence relations are extremely valuable and will be kept around for all kinds of reasons, we would like to find a *closed formula* for sequence, like we did for the binomial coefficient and the triangular numbers. The process of converting a recurrence relation with initial conditions into a closed formula that produces the same outputs, is called *solving* a recurrence relation. And the closed formula itself is called a *solution* to the recurrence relation. 

Over the next few videos we're going to look at techniques for solving recurrence relations. It can be a tricky undertaking. Sometimes solving a recurrence relation involves using visual reasoning, like we did with the triangular numbers. And sometimes it requires fairly complex counting arguments. Sometimes it involves guess-and-check. We're going to defer the process of finding solutions to recurrence relations for now, and focus on a simpler question: Given a closed formula that I think *might* solve a recurrence relation, how can I check to see if it really *is* a solution or not? 

For example, look at this recurrence relation for a sequence called a_n. It's defined recursively with a recurrence relation a_n = 3a_{n-1} - 2a_{n-2} with initial conditions a_0 = 2 and a_1 = 5. With that information, you can check (and should check if you want practice with working with recursive definitions) that the first six terms of the sequence are 2, 5, 11, 23, 47, 95. If there were a solution to this recurrence relation it would need to produce *every single one* of the *infinitely many* terms of the sequence correctly. It's definitely not obvious what a closed formula for this sequence might be, or even if there is one. But it's very easy to find some examples of formulas that are *not* solutions. A function would *fail* to be a solution if *not all* of terms are output in the same way that the recurrence relation would do it. 

For exmaple, the function f(n) = 3^n is not a solution to this recurrence relation because if we start the inputs at 0, like the recurrence relation does, it's pretty clear that the function and the sequence do not agree. g(n) = 2^n is also not a solution. 

What about the function h(n) = 1.5n^2 + 1.5n + 2? Notice that this produces the correct first three terms of the sequence but then fails at the fourth one. 

This illustrates a critically important fact: If a function produces even a single term in a sequence differently than a recurrence relation would do it, the function is not a solution to the recurrence relation. BUT: If a function produces the first few terms of a recursively-defined sequence correctly, it does NOT mean that the function solves the recurrence relation. A finite list of examples does not show that ALL POSSIBLE terms are generated correctly. 

As a more extreme example, look at this function [r\left(n\right)\ =\ 0.025n^{5}-0.125n^{4}+0.625n^{3}+0.125n^{2}+2.35n+2] that produces all six of the correct terms we started with. Does this make it a solution to the recurrence relation? No, because we haven't seen *all possible outputs*. There may be some output we haven't generated yet where the formula disagrees with the recurrence relation two disagree. And in fact that's exactly the case: for n = 6, f(6) is this number [188], but a_6 is this number [191]. **Generating examples will never prove that a function solves a recurrence relation.** But **just one counterexample will prove that a function doesn't solve a recurrence relation.**

So if I have a function and I really think it *is* a solution to a recurrence relation, how do I prove that is really is one? I can't generate all possible outputs because there are infinitely many of them. What would a convincing general argument that doesn't rely on examples look like? 

To answer that question, we need to change our perspective on the question and instead of focusing on whether the function and recurrence relation produce the same outputs, let's focus on *how a solution should behave*. A solution to a recurrence relation would have to do two things. First, it must produce all the initial conditions correctly. If the recurrence relation has a single initial condition a_0, then f(0) must equal a_0. If the indexing starts at 1, then f(1) has to equal a_1. If the recurrence relation has two initial conditions, say a_0 and a_1 then f(0) must equal a_0 *and* f(1) must equal a_1. Recurrence relations always have a *finite* list of initial conditions and so it does make sense to check whether the proposed solution agrees with all elements in that list. Doing so tells us that the function starts the sequence off the same way the recurrence relation does. 

But then, once we have checked the initial conditions, a solution must satisfy the recurrence relation. This means that if we look at the equation for the recurrence relation and replace all terms of the sequence with their corresponding function values --- a_n replaced with f(n), a_{n-1} replaced with f(n-1), and so on --- then the resulting algebra equation must be true. The left side and right sides must be equal. If this happens, then it means the function obeys the same recursion rules as the terms of the sequence. 

If the function starts off the same way as the recurrence relation and then obeys the same recursion as the recurrence relation, then this will prove that all the terms, even the ones yet to be generated, will agree. 


Let's look at an example with a very simple recurrence relation. This comes from the sequence 5, 8, 11, 14, 17, and so on that we saw in an earlier video. This is an arithmetic sequence and its recursive definition would have initial condition a_0 = 5 and for n > 0, a_n = a_{n-1} + 3. I'd like to check that f(n) = 3n+5 is a solution. I can see that it produces some of the same first few terms, but remember this does not imply that this function is a solution. Instead we have two things to do. 

First, check that f(n) satisfies the initial condition. We know that a_0 = 5. Does f(0) also equal 5? A quick plug-and-chug shows that it does. 

Now we need to check that f(n) satisfies the recurrence relation, not by plugging in specific values of n but using the formula itself. So here's the recurrence relation. Separate off the left side from the right. On the left we have a_n. Replace this with its corresponding function value f(n). The formula for this is 3n+5. Now go to the right side. We have a_{n-1} + 3. Replace the sequence term with its corresponding function value f(n-1). This notation f(n-1) means go to the function f and replace n with n-1. That gives us 3(n-1) + 5. This simplifies to 3n - 3 + 5. Now let's simplify the entire expression. We have 3n - 3 + 5 + 3, which boils down to 3n+5. Now look at the left side --- this is equal to what we computed on the right.

What this tells us is that the formula f(n) first of all produces the correct first term of the sequence, and then for every term after that it will obey the same rules of term generation as the recurrence relation. Those two things together --- a concrete function evaluation to get started and then a more abstract argument that the function obeys the recurrence relation --- put together show that *all* terms of the sequence will be produced correctly. 

Let's look at another example, going back to the earlier recurrence relation a_n = 3a_{n-1} - 2a_{n-2} with initial conditions a_0 = 2 and a_1 = 5. I claim that this function, f(n) = 3*2^n - 1 is a solution. I'm not telling how I actually got this function --- that's coming in a later video --- I just want to prove that it solves the recurrence relation. So let's first check to make sure the initial conditions are satisfied. There are two of them this time. When n = 0 the sequence term is supposed to be 2. And if I plug in n = 0 to the formula, I get 3 times 2^0 - 1 which is 3 times 1 - 1 which is indeed 2. Likewise n = 1 should produce 5, and if I plug in n = 1 I get 3 times 2^1 - 1 which is actually 5. So the initial conditions are satisfied. 

So having checked that the formula satisfies the initial conditions, we need to check whether it satisfies the recurrence relation. Here I've copied down the recurrence relation. To check, again I am going to replace all elements of the sequence which in this case are an, a_(n-1), and a_(n-2) with their corresponding function values: f(n), f(n-1), and f(n-2) respectively. So separate off the left side from the right and work with each independently. On the left, I have just a_n. Like I said, replace this with f(n). And f(n) is the formula 3 times 2 to the nth power, minus 1. 

Now on the right substitute two things: For a_(n-1) substitute f(n-1) and for a_(n-2) substitute f(n-2). Now f(n-1) can be written out further because this is the expression we get, when we take the formula for f(n) and plug in n-1 instead. So that is 3 times 2 to the n-1st power, minus 1. Likewise, f(n-2) is what we get when we take the formula for f(n) and plug in n-2. So that is 3 time 2 to the n-2nd power, minus 1. So here is where we are after we make all the substitutions. 

We're now going to try to simplify some more, using basic algebra rules. I'm not going to do a lot of explanation of the algebra here since that is prerequisite material for this course. However you might be rusty on some of this, and that's OK as long as you pause the video any time you encounter something you don't understand, and take a few minutes to try to work it out yourself and then ask questions if you need help.  

So in the first part, I can multiply this 3 to both terms in the parentheses. This gives me 3 times 3 times 2 to the n-1st, which is 9 times 2 to the n-1st, and then minus 3 after I multiply the 3 to the 1. In the second group I am going to similarly multiply the 2 through the parentheses. Now when I multiply the 2 to the first term, I could write 6 times 2 to the n-2nd power and that wouldn't be wrong. But it's simpler if I notice that when I multiply 2 to this term, there's a 2 to the n-2nd here already and multiplying it by another factor of 2, will simply raise the exponent by 1. So this is 3 times 2 to the n-1st. And then finally I need to multiply this 2 to the -1, which gives me +2 --- a 2 because 2 times 1 is 2, and plus because it's actually a minus 2 times a minus 1. 

We can combine the first and third terms to get 6 times 2^(n-1) and also the second and fourth terms to get -1. Now if I peek over to the left side, these two things don't look equal yet, but there's one more step I can do. This 6 here is the same as 3 times 2, so let me split the 6 into 3 times 2. Now the new 2 can multiply to 2^(n-1) to give me 2^n. And at last, I am left with 3 times 2^n - 1, which is what the left side is. 

This means that the function f(n) = 3 times 2^(n) - 1 solves the recurrence relation because it satisfies both the initial conditions and the recurrence relation. 

In this video, we've covered a lot of ground. We learned about what a solution to a recurrence relation is, how to show that a function is not a solution to a recurrence relation, how *not* to show that a function *is* a recurrence relation (namely by showing that the first few terms agree) and then showing how to properly check that a proposed solution to a recurrence relation really is one, without going through examples. 

Next we need to start dealing with the question of how to actually solve recurrence relations in the first place. 